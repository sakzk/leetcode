# bisect_left, bisect_right の実装 (cpython)
- 二分探索関連 https://discord.com/channels/1084280443945353267/1235971495696662578/1237425063242891315
- bisect_left/right: 区間の取り方はどちらも[0, len(s)), while (lo < hi), 脱出時の lo を返す
    - == のときに、左区間を選択するのが bisect_left, 右区間を選択するのが bisect_right。
    - left/right の振る舞いの違いを見るには、重複を含むリストを用意しないと違いがわからない (当たり前)

```python
[1, 5, 5, 10]
 0, 1,  2
 l  _  m   _  h
```

```python
bisect_right の探索ループ:
    while lo < hi:
        mid = (lo + hi) // 2
        # 本家。== を下に任せているのがわかりやすい。
        if x < key(a[mid]):
            hi = mid
        else:
            lo = mid + 1
        # == を含む形に書き換えてみた。right と left の違いは、 == の扱いの違いにある。
        # if key(a[mid]) <= x:
        #     lo = mid + 1
        # else:
        #     hi = mid
    return lo

bisect_left の探索ループ:
    while lo < hi:
        mid = (lo + hi) // 2
        if key(a[mid]) < x:
            lo = mid + 1
        else:
            hi = mid
    return lo
```

# データ構造設計問題の解き方
データ構造・アルゴリズムの選択肢の洗い出し ->  set -> get の順にやるのがよさそう
- set がちゃんと動くことを確認してから get の実装にとりかかるとよさそう。(get がうまくいかないときに set にバグがないか遡るのは大変なので)
- やってみて TLE するかどうかを見るのでは行き当たりばったりになる。TLE するにしても実装する前にどれぐらいかかりそうか見積もる。
    - 参考リンク
        - クロック数 https://discord.com/channels/1084280443945353267/1183683738635346001/1204276545577943051
        - ビッグオー記法の言葉遣い https://discord.com/channels/1084280443945353267/1192728121644945439/1233723795794165781
        - 計算理論関係の用語 https://discord.com/channels/1084280443945353267/1198621745565937764/1236328960753795112
        - 実時間で間に合うかどうかを気にする https://discord.com/channels/1084280443945353267/1227073733844406343/1235994903595712593
        - 計算量の評価が難しい例 https://discord.com/channels/1084280443945353267/1233295449985650688/1242118169968115845
    - 今回の問題は、探索対象となるリストの長さが最大で100、getメソッドの呼び出し回数が最大 2*10^5 だった。
        - 線形探索でも1秒以内に終わりそう。
- サポートする操作 set, get, update, delete
    - 一般的に気にすること
        - 重複は含まれるか、順序は気にするか、計算量の要件はあるか
        - コーナーケース：空に注意、==に注意
    - set で気にすること immutable/immutable, 参照透過性
        - update でも同様。
    - 順序付きのデータ構造に対する get: どれぐらい要素数が大きくなれば、線形探索→二分探索に変えたほうがいいのか。
        - だいたい要素数20ぐらいで、二分探索のほうが早くなる https://discord.com/channels/1084280443945353267/1192736784354918470/1199348106949558334, https://discord.com/channels/1084280443945353267/1200089668901937312/1203010805084332062
        - ソートを保つのは set が O(n) になるのとトレードオフ
            - 線形リストに対しては二分探索を O(lon_n) でできない。dict[index] = Node となるような連想配列を用意しても、delete, insert にともなうインデックスの更新に結局 O(n) かかるので。
            - dict(key, Node) はあり得る。 参照　LRU-cache https://leetcode.com/problems/lru-cache/description/
- set, get を同時に実行するとどうなるか、も気にする必要があるかも


# とても大きなテストケース(10^5ぐらい)をコピペすると、コピペに時間がかかる。
1. vim で開いたテスト用のファイルにテストケースをペーストしたところ、ペーストがしばらく終わらなかった。
2. ファイルを開いている vim のプロセスを、`kill -9 PID` で kill したところ、プロンプトに切り替わり、プロンプトへのペーストが継続した。
3. `ps -x | grep <vimで開いていたファイル名>` でペーストを継続しているプロセスを探してみたが見つけられなかった。

→ vim を kill してもターミナルエミュレータ上でのペーストが継続する現象には、ターミナルエミュレータのペーストバッファというのが関係しているらしい。
メカニズムはよくわかっていないが、ターミナルエミュレータから vim への出力が、どうにかしてプロンプトに切り替わっている。
